"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const index_1 = require("./index");
const utils_1 = require("./utils");
const context_helper_1 = require("./context-helper");
/**
 * Git Helper
 */
class GitHelper {
    /**
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {number|undefined} options.depth depth
     * @param {function|undefined} options.filter filter
     */
    constructor(logger, options) {
        this.logger = logger;
        /**
         * @param {string} workDir work dir
         * @param {string[]} commands commands
         * @return {Promise<{}[]>} void
         */
        this.runCommand = (workDir, commands) => __awaiter(this, void 0, void 0, function* () {
            const result = [];
            try {
                for (const command of (Array.isArray(commands) ? commands : [commands])) {
                    if (typeof command === 'string') {
                        const output = (yield this.command.execAsync({ command, cwd: workDir }));
                        result.push({
                            command: output.command,
                            stdout: utils_1.split(output.stdout),
                            stderr: utils_1.split(output.stderr),
                        });
                    }
                    else {
                        const output = (yield this.command.execAsync(Object.assign({ cwd: workDir }, command)));
                        result.push({
                            command: output.command,
                            stdout: utils_1.split(output.stdout),
                            stderr: utils_1.split(output.stderr),
                        });
                    }
                }
                return result;
            }
            catch (error) {
                console.log();
                console.log(error);
                throw error;
            }
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<string>} branch name
         */
        this.getCurrentBranchName = (workDir) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!utils_1.isCloned(workDir)) {
                return '';
            }
            // eslint-disable-next-line no-magic-numbers
            return _b = (_a = (yield this.runCommand(workDir, { command: 'git branch', args: ['-a'] }))[0].stdout.find(branch => branch.startsWith('*'))) === null || _a === void 0 ? void 0 : _a.slice(2).trim(), (_b !== null && _b !== void 0 ? _b : '');
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.cloneBranch = (workDir, branch, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            yield this.runCommand(workDir, {
                command: 'git clone',
                args: [`--branch=${branch}`, this.cloneDepth, url, '.'],
                quiet: true,
                altCommand: `git clone --branch=${branch}`,
                suppressError: true,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.clonePR = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            yield this.runCommand(workDir, [
                {
                    command: 'git clone',
                    args: [this.cloneDepth, url, '.'],
                    quiet: true,
                    altCommand: 'git clone',
                    suppressError: true,
                },
                {
                    command: 'git fetch',
                    args: ['origin', `+${context.ref}`],
                    stderrToStdout: true,
                },
                'git checkout -qf FETCH_HEAD',
            ]);
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.clone = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            if (utils_1.isCloned(workDir)) {
                return;
            }
            if (utils_1.isBranch(context)) {
                yield this.cloneBranch(workDir, utils_1.getBranch(context), context);
            }
            else if (utils_1.isPrRef(context)) {
                yield this.clonePR(workDir, context);
            }
            else {
                yield this.checkout(workDir, context);
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.checkout = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            if (this.cloneDepth && context.sha) {
                yield this.runCommand(workDir, [
                    {
                        command: 'git clone',
                        args: [this.cloneDepth, url, '.'],
                        quiet: true,
                        altCommand: 'git clone',
                    },
                    {
                        command: 'git fetch',
                        args: [url, context.ref],
                        quiet: true,
                        altCommand: `git fetch origin ${context.ref}`,
                    },
                    {
                        command: 'git checkout',
                        args: ['-qf', context.sha],
                    },
                ]);
            }
            else {
                const checkout = context.sha || utils_1.getBranch(context) || context.ref;
                if (!checkout) {
                    throw new Error('Invalid context.');
                }
                yield this.runCommand(workDir, [
                    {
                        command: 'git clone',
                        args: [url, '.'],
                        quiet: true,
                        altCommand: 'git clone',
                    },
                    {
                        command: 'git checkout',
                        args: ['-qf', checkout],
                    },
                ]);
            }
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<void>} void
         */
        this.initialize = (workDir) => __awaiter(this, void 0, void 0, function* () {
            yield this.runCommand(workDir, { command: 'rm', args: ['-rdf', workDir] });
            fs_1.default.mkdirSync(workDir, { recursive: true });
            yield this.runCommand(workDir, { command: 'git init', args: ['.'] });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.gitInit = (workDir, branch) => __awaiter(this, void 0, void 0, function* () {
            yield this.initialize(workDir);
            yield this.runCommand(workDir, { command: 'git checkout', args: ['--orphan', branch], stderrToStdout: true });
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.addOrigin = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            yield this.initialize(workDir);
            yield this.runCommand(workDir, {
                command: 'git remote add',
                args: ['origin', url],
                quiet: true,
                altCommand: 'git remote add origin',
                suppressError: true,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.fetchOrigin = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            yield this.addOrigin(workDir, context);
            yield this.runCommand(workDir, { command: 'git fetch', args: ['origin'], stderrToStdout: true });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.fetchBranch = (workDir, branch, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            const branchName = utils_1.getBranch(branch, false);
            yield this.runCommand(workDir, {
                command: 'git fetch',
                args: ['--prune', '--no-recurse-submodules', this.cloneDepth, url, `+refs/heads/${branchName}:refs/remotes/origin/${branchName}`],
                quiet: true,
                altCommand: `git fetch --prune --no-recurse-submodules${this.cloneDepth} origin +refs/heads/${branchName}:refs/remotes/origin/${branchName}`,
                suppressError: true,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.createBranch = (workDir, branch) => __awaiter(this, void 0, void 0, function* () {
            yield this.runCommand(workDir, { command: 'git checkout', args: ['-b', branch], stderrToStdout: true });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.switchBranch = (workDir, branch) => __awaiter(this, void 0, void 0, function* () {
            yield this.runCommand(workDir, {
                command: 'git checkout',
                args: ['-b', branch, `origin/${branch}`],
                suppressError: true,
                stderrToStdout: true,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} name name
         * @param {string} email email
         * @return {Promise<void>} void
         */
        this.config = (workDir, name, email) => __awaiter(this, void 0, void 0, function* () {
            yield this.runCommand(workDir, [
                {
                    command: 'git config',
                    args: ['user.name', name],
                },
                {
                    command: 'git config',
                    args: ['user.email', email],
                },
            ]);
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<string[]>} diff
         */
        this.getDiff = (workDir) => __awaiter(this, void 0, void 0, function* () {
            return (yield this.runCommand(workDir, {
                command: 'git status',
                args: ['--short', '-uno'],
                suppressOutput: true,
            }))[0].stdout.filter(line => line.match(/^[MDA]\s+/)).filter(this.filter).map(line => line.replace(/^[MDA]\s+/, ''));
        });
        /**
         * @param {string} workDir work dir
         * @param {string} baseRef base ref
         * @param {string} compareRef compare ref
         * @param {string} diffFilter diff filter
         * @param {string} dot dot
         * @return {Promise<string[]>} diff
         */
        this.getRefDiff = (workDir, baseRef, compareRef, diffFilter, dot) => __awaiter(this, void 0, void 0, function* () {
            const toDiffRef = (ref) => 'HEAD' === ref ? 'HEAD' : (utils_1.isPrRef(ref) ? ref.replace(/^refs\//, '') : `origin/${utils_1.getBranch(ref, false)}`);
            return (yield this.runCommand(workDir, {
                command: 'git diff',
                args: [`${toDiffRef(baseRef)}${dot ? dot : '...'}${toDiffRef(compareRef)}`, `--name-only${diffFilter ? ` --diff-filter=${diffFilter}` : ''}`],
                suppressOutput: true,
            }))[0].stdout.filter(item => !!item.trim());
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<boolean>} result
         */
        this.checkDiff = (workDir) => __awaiter(this, void 0, void 0, function* () { return !!(yield this.getDiff(workDir)).length; });
        /**
         * @param {string} workDir work dir
         * @param {string} message message
         */
        this.commit = (workDir, message) => __awaiter(this, void 0, void 0, function* () {
            yield this.runCommand(workDir, { command: 'git add', args: ['--all'] });
            if (!(yield this.checkDiff(workDir))) {
                this.logger.info('There is no diff.');
                return false;
            }
            yield this.makeCommit(workDir, message);
            return true;
        });
        /**
         * @param {string} workDir work dir
         * @param {string} message message
         * @param {number} count stat count
         */
        this.makeCommit = (workDir, message, count = 10) => __awaiter(this, void 0, void 0, function* () {
            yield this.runCommand(workDir, [
                {
                    command: 'git commit',
                    args: ['-qm', message],
                },
                {
                    command: 'git show',
                    args: [`--stat-count=${count}`, 'HEAD'],
                },
            ]);
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<string[]>} tags
         */
        this.getTags = (workDir) => __awaiter(this, void 0, void 0, function* () {
            return (yield this.runCommand(workDir, {
                command: 'git tag', args: ['-l'],
            }))[0].stdout;
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         * @see https://qiita.com/ngyuki/items/ca7bed067d7e538fd0cd
         */
        this.fetchTags = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            yield this.runCommand(workDir, [
                {
                    command: 'git tag',
                    args: ['-d', ...yield this.getTags(workDir)],
                },
                {
                    command: 'git fetch',
                    args: [url, '--tags'],
                    quiet: true,
                    altCommand: 'git fetch origin --tags',
                },
            ]);
        });
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.deleteTag = (workDir, tags, context) => __awaiter(this, void 0, void 0, function* () {
            if ('string' === typeof tags) {
                const url = context_helper_1.getGitUrl(context);
                yield this.runCommand(workDir, {
                    command: 'git push',
                    args: ['--delete', url, 'tag', tags],
                    quiet: true,
                    altCommand: `git push --delete origin tag ${tags}`,
                    suppressError: true,
                });
            }
            else {
                for (const tag of tags) {
                    yield this.deleteTag(workDir, tag, context);
                }
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {string} newTag new tag
         * @param {string} fromTag from tag
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.copyTag = (workDir, newTag, fromTag, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            yield this.deleteTag(workDir, newTag, context);
            yield this.runCommand(workDir, [
                {
                    command: 'git tag',
                    args: [newTag, fromTag],
                },
                {
                    command: 'git push',
                    args: [url, `refs/tags/${newTag}`],
                    quiet: true,
                    altCommand: `git push origin refs/tags/${newTag}`,
                },
            ]);
        });
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @return {Promise<void>} void
         */
        this.addLocalTag = (workDir, tags) => __awaiter(this, void 0, void 0, function* () {
            if ('string' === typeof tags) {
                yield this.runCommand(workDir, { command: 'git tag', args: [tags] });
            }
            else {
                for (const tag of tags) {
                    yield this.addLocalTag(workDir, tag);
                }
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {boolean} withTag with tag?
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.push = (workDir, branch, withTag, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            const tags = withTag ? ' --tags' : '';
            yield this.runCommand(workDir, {
                command: 'git push',
                args: [withTag ? '--tags' : '', url, `${branch}:refs/heads/${branch}`],
                quiet: true,
                altCommand: `git push${tags} origin ${branch}:refs/heads/${branch}`,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.forcePush = (workDir, branch, context) => __awaiter(this, void 0, void 0, function* () {
            const url = context_helper_1.getGitUrl(context);
            yield this.runCommand(workDir, {
                command: 'git push',
                args: ['--force', url, `${branch}:refs/heads/${branch}`],
                quiet: true,
                altCommand: `git push --force origin ${branch}:refs/heads/${branch}`,
            });
        });
        /**
         * @param {string} workDir work dir
         * @return {string} tag
         */
        this.getLastTag = (workDir) => __awaiter(this, void 0, void 0, function* () {
            var _c;
            if (!utils_1.isCloned(workDir)) {
                throw new Error('Not a git repository');
            }
            const tags = (yield this.getTags(workDir)).filter(tag => /^v?\d+(\.\d+)*$/.test(tag)).map(tag => tag.replace(/^v/, ''));
            const splitTag = (tag) => tag.split('.').map(item => Number(item));
            // eslint-disable-next-line no-magic-numbers
            const compare = (tag1, tag2, num = 0) => {
                var _a, _b;
                if (tag1.length <= num && tag2.length <= num) {
                    return Math.sign(tag2.length - tag1.length);
                }
                // eslint-disable-next-line no-magic-numbers
                const val1 = (_a = tag1[num], (_a !== null && _a !== void 0 ? _a : 0)), val2 = (_b = tag2[num], (_b !== null && _b !== void 0 ? _b : 0));
                return val1 === val2 ? compare(tag1, tag2, ++num) : Math.sign(val2 - val1);
            };
            const compareTag = (tag1, tag2) => compare(splitTag(tag1), splitTag(tag2));
            return 'v' + (_c = tags.slice().sort(compareTag)[0], (_c !== null && _c !== void 0 ? _c : '0.0.0'));
        });
        /**
         * @param {string} workDir work dir
         * @return {string} tag
         */
        this.getNewPatchVersion = (workDir) => __awaiter(this, void 0, void 0, function* () { return utils_1.generateNewPatchVersion(yield this.getLastTag(workDir)); });
        this.command = new index_1.Command(logger);
        if (options && options.depth) {
            this.cloneDepth = options.depth > 0 ? `--depth=${options.depth}` : ''; // eslint-disable-line no-magic-numbers
        }
        else {
            this.cloneDepth = '--depth=3';
        }
        if (options && options.filter) {
            this.filter = options.filter;
        }
        else {
            this.filter = (line) => !!line.trim();
        }
    }
}
exports.default = GitHelper;
