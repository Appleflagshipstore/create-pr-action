"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const github_action_helper_1 = require("@technote-space/github-action-helper");
const filter_github_action_1 = require("@technote-space/filter-github-action");
const constant_1 = require("../constant");
const { getWorkspace, getPrefixRegExp } = github_action_helper_1.Utils;
const { escapeRegExp, replaceAll, getBranch } = github_action_helper_1.Utils;
const { isPr, isCron, isPush } = github_action_helper_1.ContextHelper;
exports.getActionDetail = (key, context, defaultValue) => {
    if (undefined === defaultValue && !(key in context.actionDetail)) {
        throw new Error(`parameter [${key}] is required.`);
    }
    if (undefined === defaultValue && typeof context.actionDetail[key] === 'string' && context.actionDetail[key].trim() === '') {
        throw new Error(`parameter [${key}] is required.`);
    }
    return context.actionDetail[key] || (typeof defaultValue === 'function' ? defaultValue() : undefined);
};
exports.replaceDirectory = (message) => {
    const workDir = getWorkspace();
    return replaceAll(replaceAll(message, ` -C ${workDir}`, ''), workDir, '[Working Directory]');
};
exports.getDefaultBranchUrl = (context) => `https://github.com/${context.actionContext.repo.owner}/${context.actionContext.repo.repo}/tree/${context.defaultBranch}`;
exports.getPrHeadRef = (context) => { var _a, _b; return _b = (_a = context.actionContext.payload.pull_request) === null || _a === void 0 ? void 0 : _a.head.ref, (_b !== null && _b !== void 0 ? _b : ''); };
exports.getPrBaseRef = (context) => { var _a, _b; return _b = (_a = context.actionContext.payload.pull_request) === null || _a === void 0 ? void 0 : _a.base.ref, (_b !== null && _b !== void 0 ? _b : ''); };
const getPrBranchPrefix = (context) => context.actionDetail.prBranchPrefix || `${context.actionDetail.actionRepo}/`;
const getPrBranchPrefixForDefaultBranch = (context) => context.actionDetail.prBranchPrefixForDefaultBranch || getPrBranchPrefix(context);
exports.isActionPr = (context) => getPrefixRegExp(getPrBranchPrefix(context)).test(exports.getPrHeadRef(context)) || getPrefixRegExp(getPrBranchPrefixForDefaultBranch(context)).test(exports.getPrHeadRef(context));
exports.isDefaultBranch = (context) => context.defaultBranch === (context.isBatchProcess ? exports.getPrBaseRef(context) : getBranch(context.actionContext));
exports.checkDefaultBranch = (context) => { var _a; return _a = context.actionDetail.checkDefaultBranch, (_a !== null && _a !== void 0 ? _a : true); };
exports.isDisabledDeletePackage = (context) => { var _a; return !(_a = context.actionDetail.deletePackage, (_a !== null && _a !== void 0 ? _a : false)); };
exports.isClosePR = (context) => isPr(context.actionContext) && context.actionContext.payload.action === 'closed';
exports.isTargetBranch = (branchName, context) => {
    if (branchName === context.defaultBranch) {
        return exports.checkDefaultBranch(context);
    }
    const prefix = exports.getActionDetail('targetBranchPrefix', context, () => '');
    if (prefix) {
        return getPrefixRegExp(prefix).test(branchName);
    }
    return true;
};
exports.isTargetContext = (context) => {
    var _a;
    if (!filter_github_action_1.isTargetEvent((_a = context.actionDetail.targetEvents, (_a !== null && _a !== void 0 ? _a : constant_1.DEFAULT_TARGET_EVENTS)), context.actionContext)) {
        return false;
    }
    if (isCron(context.actionContext)) {
        return true;
    }
    if (isPush(context.actionContext)) {
        return exports.isTargetBranch(getBranch(context.actionContext), context);
    }
    if (exports.isActionPr(context)) {
        return true;
    }
    if (exports.isClosePR(context)) {
        return true;
    }
    if (!exports.isTargetBranch(exports.getPrHeadRef(context), context)) {
        return false;
    }
    return filter_github_action_1.isTargetLabels(exports.getActionDetail('includeLabels', context, () => []), [], context.actionContext);
};
exports.getGitFilterStatus = (context) => context.actionDetail.filterGitStatus;
exports.filterGitStatus = (line, context) => {
    const filter = exports.getGitFilterStatus(context);
    if (filter) {
        const targets = filter.toUpperCase().replace(/[^MDA]/g, '');
        if (!targets) {
            throw new Error('Invalid input [FILTER_GIT_STATUS].');
        }
        // language=JSRegexp
        return (new RegExp(`^[${targets}]\\s+`)).test(line);
    }
    return true;
};
exports.filterExtension = (line, context) => {
    const extensions = exports.getActionDetail('filterExtensions', context, () => []);
    if (extensions.length) {
        const pattern = '(' + extensions.map(item => escapeRegExp('.' + item.replace(/^\./, ''))).join('|') + ')';
        return (new RegExp(`${pattern}$`)).test(line);
    }
    return true;
};
exports.getHelper = (context) => new github_action_helper_1.GitHelper(new github_action_helper_1.Logger(exports.replaceDirectory), {
    depth: -1,
    filter: (line) => exports.filterGitStatus(line, context) && exports.filterExtension(line, context),
});
exports.getPullsArgsForDefaultBranch = (context) => ({
    number: 0,
    id: 0,
    head: {
        ref: context.defaultBranch,
    },
    base: {
        repo: {
            name: context.actionContext.repo.repo,
            owner: {
                login: context.actionContext.repo.owner,
            },
        },
        ref: context.defaultBranch,
    },
    title: 'default branch',
    'html_url': exports.getDefaultBranchUrl(context),
});
