"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const github_action_helper_1 = require("@technote-space/github-action-helper");
const filter_github_action_1 = require("@technote-space/filter-github-action");
const moment_1 = __importDefault(require("moment"));
const constant_1 = require("../constant");
const command_1 = require("./command");
const { getWorkspace, getPrefixRegExp, getRegExp } = github_action_helper_1.Utils;
const { escapeRegExp, replaceAll, getBranch } = github_action_helper_1.Utils;
const { isPr, isCron, isPush } = github_action_helper_1.ContextHelper;
exports.getActionDetail = (key, context, defaultValue) => {
    var _a;
    if (undefined === defaultValue && !(key in context.actionDetail)) {
        throw new Error(`parameter [${key}] is required.`);
    }
    if (undefined === defaultValue && typeof context.actionDetail[key] === 'string' && context.actionDetail[key].trim() === '') {
        throw new Error(`parameter [${key}] is required.`);
    }
    return _a = context.actionDetail[key], (_a !== null && _a !== void 0 ? _a : defaultValue);
};
exports.getCommitMessage = (context) => exports.getActionDetail('commitMessage', context);
exports.getCommitName = (context) => exports.getActionDetail('commitName', context, constant_1.DEFAULT_COMMIT_NAME);
exports.getCommitEmail = (context) => exports.getActionDetail('commitEmail', context, constant_1.DEFAULT_COMMIT_EMAIL);
exports.replaceDirectory = (message) => {
    const workDir = getWorkspace();
    return replaceAll(replaceAll(message, ` -C ${workDir}`, ''), workDir, '[Working Directory]');
};
const getVariable = (index, context) => exports.getActionDetail('prVariables', context)[index];
const getDate = (index, context) => moment_1.default().format(exports.getActionDetail('prDateFormats', context)[index]);
const getDefaultBranchUrl = (context) => `https://github.com/${context.actionContext.repo.owner}/${context.actionContext.repo.repo}/tree/${context.defaultBranch}`;
/**
 * @param {GitHelper} helper git helper
 * @param {ActionContext} context context
 * @return {{string, Function}[]} replacer
 */
const contextVariables = (helper, context) => {
    var _a, _b, _c, _d;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const getPrParamFunc = (extractor) => () => __awaiter(void 0, void 0, void 0, function* () {
        if (!context.actionContext.payload.pull_request) {
            throw new Error('Invalid context.');
        }
        return extractor(context.actionContext.payload.pull_request);
    });
    return [
        { key: 'PR_NUMBER', replace: getPrParamFunc(pr => pr.number) },
        { key: 'PR_NUMBER_REF', replace: getPrParamFunc(pr => pr.number ? `#${pr.number}` : getDefaultBranchUrl(context)) },
        { key: 'PR_ID', replace: getPrParamFunc(pr => pr.id) },
        { key: 'PR_HEAD_REF', replace: getPrParamFunc(pr => pr.head.ref) },
        { key: 'PR_BASE_REF', replace: getPrParamFunc(pr => pr.base.ref) },
        { key: 'PR_TITLE', replace: getPrParamFunc(pr => pr.title) },
        { key: 'PR_URL', replace: getPrParamFunc(pr => pr.html_url) },
        { key: 'PR_MERGE_REF', replace: getPrParamFunc(pr => pr.number ? `${pr.head.ref} -> ${pr.base.ref}` : context.defaultBranch) },
        { key: 'PATCH_VERSION', replace: () => command_1.getNewPatchVersion(helper) },
    ].concat([...Array((_b = (_a = context.actionDetail.prVariables) === null || _a === void 0 ? void 0 : _a.length, (_b !== null && _b !== void 0 ? _b : 0))).keys()].map(index => ({
        // eslint-disable-next-line no-magic-numbers
        key: `VARIABLE${index + 1}`, replace: () => __awaiter(void 0, void 0, void 0, function* () { return getVariable(index, context); }),
    }))).concat([...Array((_d = (_c = context.actionDetail.prDateFormats) === null || _c === void 0 ? void 0 : _c.length, (_d !== null && _d !== void 0 ? _d : 0))).keys()].map(index => ({
        // eslint-disable-next-line no-magic-numbers
        key: `DATE${index + 1}`, replace: () => __awaiter(void 0, void 0, void 0, function* () { return getDate(index, context); }),
    })));
};
/**
 * @param {string} string string
 * @param {object[]} variables variables
 * @return {string} replaced
 */
const replaceVariables = (string, variables) => __awaiter(void 0, void 0, void 0, function* () {
    let replaced = string;
    for (const variable of variables) {
        if (getRegExp(`\${${variable.key}}`).test(replaced)) {
            replaced = replaceAll(replaced, `\${${variable.key}}`, yield variable.replace());
        }
    }
    return replaced;
});
/**
 * @param {string} string string
 * @param {GitHelper} helper git helper
 * @param {ActionDetails} context action details
 * @return {Promise<string>} replaced
 */
const replaceContextVariables = (string, helper, context) => replaceVariables(string, contextVariables(helper, context));
exports.getPrHeadRef = (context) => { var _a, _b; return _b = (_a = context.actionContext.payload.pull_request) === null || _a === void 0 ? void 0 : _a.head.ref, (_b !== null && _b !== void 0 ? _b : ''); };
exports.getPrBaseRef = (context) => { var _a, _b; return _b = (_a = context.actionContext.payload.pull_request) === null || _a === void 0 ? void 0 : _a.base.ref, (_b !== null && _b !== void 0 ? _b : ''); };
const getPrBranchPrefix = (context) => context.actionDetail.prBranchPrefix || `${context.actionDetail.actionRepo}/`;
const getPrBranchPrefixForDefaultBranch = (context) => context.actionDetail.prBranchPrefixForDefaultBranch || getPrBranchPrefix(context);
exports.isActionPr = (context) => getPrefixRegExp(getPrBranchPrefix(context)).test(exports.getPrHeadRef(context)) || getPrefixRegExp(getPrBranchPrefixForDefaultBranch(context)).test(exports.getPrHeadRef(context));
exports.getPrBranchName = (helper, context) => __awaiter(void 0, void 0, void 0, function* () {
    return isPush(context.actionContext) ?
        getBranch(context.actionContext) :
        (context.defaultBranch === getBranch(context.actionContext) ?
            getPrBranchPrefixForDefaultBranch(context) + (yield replaceContextVariables(exports.getActionDetail('prBranchNameForDefaultBranch', context, exports.getActionDetail('prBranchName', context)), helper, context)) :
            getPrBranchPrefix(context) + (yield replaceContextVariables(exports.getActionDetail('prBranchName', context), helper, context)));
});
exports.getPrTitle = (helper, context) => __awaiter(void 0, void 0, void 0, function* () { return replaceContextVariables(exports.getActionDetail('prTitle', context), helper, context); });
exports.getPrLink = (context) => context.actionContext.payload.pull_request ? `[${context.actionContext.payload.pull_request.title}](${context.actionContext.payload.pull_request.html_url})` : '';
const prBodyVariables = (files, output, helper, context) => {
    const toCode = (string) => string.length ? ['', '```Shell', string, '```', ''].join('\n') : '';
    return [
        {
            key: 'PR_LINK',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return exports.getPrLink(context); }),
        },
        {
            key: 'COMMANDS',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return output.length ? toCode(output.map(item => `$ ${item.command}`).join('\n')) : ''; }),
        },
        {
            key: 'COMMANDS_STDOUT',
            replace: () => __awaiter(void 0, void 0, void 0, function* () {
                return output.length ? '<details>\n' + output.map(item => [
                    `<summary><em>${item.command}</em></summary>`,
                    toCode(item.stdout.join('\n')),
                ].join('\n')).join('\n</details>\n<details>\n') + '\n</details>' : '';
            }),
        },
        {
            key: 'COMMANDS_OUTPUT',
            replace: () => __awaiter(void 0, void 0, void 0, function* () {
                return output.length ? '<details>\n' + output.map(item => [
                    `<summary><em>${item.command}</em></summary>`,
                    toCode(item.stdout.join('\n')),
                    item.stderr.length ? '### stderr:' : '',
                    toCode(item.stderr.join('\n')),
                ].join('\n')).join('\n</details>\n<details>\n') + '\n</details>' : '';
            }),
        },
        {
            key: 'COMMANDS_STDOUT_OPENED',
            replace: () => __awaiter(void 0, void 0, void 0, function* () {
                return output.length ? '<details open>\n' + output.map(item => [
                    `<summary><em>${item.command}</em></summary>`,
                    toCode(item.stdout.join('\n')),
                ].join('\n')).join('\n</details>\n<details open>\n') + '\n</details>' : '';
            }),
        },
        {
            key: 'COMMANDS_STDERR',
            replace: () => __awaiter(void 0, void 0, void 0, function* () {
                return output.length ? '<details>\n' + output.map(item => [
                    `<summary><em>${item.command}</em></summary>`,
                    toCode(item.stderr.join('\n')),
                ].join('\n')).join('\n</details>\n<details>\n') + '\n</details>' : '';
            }),
        },
        {
            key: 'COMMANDS_STDERR_OPENED',
            replace: () => __awaiter(void 0, void 0, void 0, function* () {
                return output.length ? '<details open>\n' + output.map(item => [
                    `<summary><em>${item.command}</em></summary>`,
                    toCode(item.stderr.join('\n')),
                ].join('\n')).join('\n</details>\n<details open>\n') + '\n</details>' : '';
            }),
        },
        {
            key: 'FILES',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return files.map(file => `- ${file}`).join('\n'); }),
        },
        {
            key: 'FILES_SUMMARY',
            // eslint-disable-next-line no-magic-numbers
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return 'Changed ' + (files.length > 1 ? `${files.length} files` : 'file'); }),
        },
        {
            key: 'ACTION_NAME',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return context.actionDetail.actionName; }),
        },
        {
            key: 'ACTION_OWNER',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return context.actionDetail.actionOwner; }),
        },
        {
            key: 'ACTION_REPO',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return context.actionDetail.actionRepo; }),
        },
        {
            key: 'ACTION_URL',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return `https://github.com/${context.actionDetail.actionOwner}/${context.actionDetail.actionRepo}`; }),
        },
        {
            key: 'ACTION_MARKETPLACE_URL',
            replace: () => __awaiter(void 0, void 0, void 0, function* () { return `https://github.com/marketplace/actions/${context.actionDetail.actionRepo}`; }),
        },
    ].concat(contextVariables(helper, context));
};
const replacePrBodyVariables = (prBody, files, output, helper, context) => replaceVariables(prBody, prBodyVariables(files, output, helper, context));
exports.getPrBody = (files, output, helper, context) => __awaiter(void 0, void 0, void 0, function* () {
    return replacePrBodyVariables(exports.getActionDetail('prBody', context).trim().split(/\r?\n/).map(line => line.replace(/^[\s\t]+/, '')).join('\n'), files, output, helper, context);
});
exports.checkDefaultBranch = (context) => { var _a; return _a = context.actionDetail.checkDefaultBranch, (_a !== null && _a !== void 0 ? _a : true); };
exports.isDisabledDeletePackage = (context) => { var _a; return !(_a = context.actionDetail.deletePackage, (_a !== null && _a !== void 0 ? _a : false)); };
exports.isClosePR = (context) => isPr(context.actionContext) && context.actionContext.payload.action === 'closed';
exports.isTargetBranch = (branchName, context) => {
    if (branchName === context.defaultBranch) {
        return exports.checkDefaultBranch(context);
    }
    const prefix = exports.getActionDetail('targetBranchPrefix', context, '');
    if (prefix) {
        return getPrefixRegExp(prefix).test(branchName);
    }
    return true;
};
exports.isTargetContext = (context) => {
    var _a;
    if (!filter_github_action_1.isTargetEvent((_a = context.actionDetail.targetEvents, (_a !== null && _a !== void 0 ? _a : constant_1.DEFAULT_TARGET_EVENTS)), context.actionContext)) {
        return false;
    }
    if (isCron(context.actionContext)) {
        return true;
    }
    if (isPush(context.actionContext)) {
        return exports.isTargetBranch(getBranch(context.actionContext), context);
    }
    if (exports.isActionPr(context)) {
        return true;
    }
    if (!exports.isTargetBranch(exports.getPrHeadRef(context), context)) {
        return false;
    }
    return filter_github_action_1.isTargetLabels(exports.getActionDetail('includeLabels', context, []), [], context.actionContext);
};
exports.getGitFilterStatus = (context) => context.actionDetail.filterGitStatus;
exports.filterGitStatus = (line, context) => {
    const filter = exports.getGitFilterStatus(context);
    if (filter) {
        const targets = filter.toUpperCase().replace(/[^MDA]/g, '');
        if (!targets) {
            throw new Error('Invalid input [FILTER_GIT_STATUS].');
        }
        // language=JSRegexp
        return (new RegExp(`^[${targets}]\\s+`)).test(line);
    }
    return true;
};
exports.filterExtension = (line, context) => {
    const extensions = exports.getActionDetail('filterExtensions', context, []);
    if (extensions.length) {
        const pattern = '(' + extensions.map(item => escapeRegExp('.' + item.replace(/^\./, ''))).join('|') + ')';
        return (new RegExp(`${pattern}$`)).test(line);
    }
    return true;
};
exports.getHelper = (context) => new github_action_helper_1.GitHelper(new github_action_helper_1.Logger(exports.replaceDirectory), {
    depth: -1,
    filter: (line) => exports.filterGitStatus(line, context) && exports.filterExtension(line, context),
});
exports.getPullsArgsForDefaultBranch = (context) => ({
    number: 0,
    id: 0,
    head: {
        ref: context.defaultBranch,
    },
    base: {
        repo: {
            name: context.actionContext.repo.repo,
            owner: {
                login: context.actionContext.repo.owner,
            },
        },
        ref: context.defaultBranch,
    },
    title: 'default branch',
    'html_url': getDefaultBranchUrl(context),
});
//# sourceMappingURL=misc.js.map