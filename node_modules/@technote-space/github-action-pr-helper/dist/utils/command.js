"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@actions/core");
const github_1 = require("@actions/github");
const github_action_helper_1 = require("@technote-space/github-action-helper");
const misc_1 = require("./misc");
const variables_1 = require("./variables");
const { getWorkspace, useNpm } = github_action_helper_1.Utils;
const { getRepository, isPush } = github_action_helper_1.ContextHelper;
exports.getApiHelper = (octokit, context, logger) => new github_action_helper_1.ApiHelper(octokit, context.actionContext, logger);
exports.clone = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Fetching...');
    yield helper.fetchOrigin(getWorkspace(), context.actionContext);
    const branchName = yield variables_1.getPrBranchName(helper, logger, octokit, context);
    logger.startProcess('Switching branch to [%s]...', branchName);
    yield helper.switchBranch(getWorkspace(), branchName);
});
exports.checkBranch = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const clonedBranch = yield helper.getCurrentBranchName(getWorkspace());
    const branchName = yield variables_1.getPrBranchName(helper, logger, octokit, context);
    if (branchName === clonedBranch) {
        yield helper.runCommand(getWorkspace(), 'ls -la');
        return !isPush(context.actionContext);
    }
    if (isPush(context.actionContext)) {
        throw new Error(`remote branch [${branchName}] not found.`);
    }
    logger.info('remote branch [%s] not found.', branchName);
    logger.info('now branch: %s', clonedBranch);
    logger.startProcess('Cloning [%s] from the remote repo...', misc_1.getPrHeadRef(context));
    yield helper.switchBranch(getWorkspace(), misc_1.getPrHeadRef(context));
    yield helper.createBranch(getWorkspace(), branchName);
    yield helper.runCommand(getWorkspace(), 'ls -la');
    return false;
});
const getClearPackageCommands = (context) => {
    if (misc_1.isDisabledDeletePackage(context)) {
        return [];
    }
    return [
        'rm -f package.json',
        'rm -f package-lock.json',
        'rm -f yarn.lock',
    ];
};
const getGlobalInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('globalInstallPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'sudo npm install -g ' + packages.join(' '),
            ];
        }
        else {
            return [
                'sudo yarn global add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getDevInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('devInstallPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save-dev ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add --dev ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('installPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const normalizeCommand = (command) => command.trim().replace(/\s{2,}/g, ' ');
const getExecuteCommands = (context) => misc_1.getActionDetail('executeCommands', context, () => []).map(normalizeCommand);
exports.getDiff = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Checking diff...');
    yield helper.runCommand(getWorkspace(), 'git add --all');
    return yield helper.getDiff(getWorkspace());
});
exports.getRefDiff = (compare, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Checking references diff...');
    yield helper.fetchBranch(getWorkspace(), compare, context.actionContext);
    return (yield helper.getRefDiff(getWorkspace(), 'HEAD', compare, misc_1.getGitFilterStatus(context), '..')).filter(line => misc_1.filterExtension(line, context));
});
const initDirectory = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Initializing working directory...');
    yield helper.addOrigin(getWorkspace(), context.actionContext);
});
exports.config = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    const name = variables_1.getCommitName(context);
    const email = variables_1.getCommitEmail(context);
    logger.startProcess('Configuring git committer to be %s <%s>', name, email);
    yield helper.config(getWorkspace(), name, email);
});
exports.merge = (branch, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.config(helper, logger, context);
    logger.startProcess('Merging [%s] branch...', branch.replace(/^(refs\/)?heads/, ''));
    const results = yield helper.runCommand(getWorkspace(), `git merge --no-edit origin/${branch.replace(/^(refs\/)?heads/, '')} || :`);
    return !results[0].stdout.some(RegExp.prototype.test, /^CONFLICT /);
});
exports.abortMerge = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Aborting merge...');
    yield helper.runCommand(getWorkspace(), 'git merge --abort');
});
exports.commit = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.config(helper, logger, context);
    logger.startProcess('Committing...');
    yield helper.makeCommit(getWorkspace(), variables_1.getCommitMessage(context));
});
exports.push = (branchName, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    yield helper.push(getWorkspace(), branchName, false, context.actionContext);
});
const forcePush = (branchName, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    yield helper.forcePush(getWorkspace(), branchName, context.actionContext);
});
exports.isMergeable = (number, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    return misc_1.getCache(misc_1.getCacheKey('pulls.get', {
        owner: context.actionContext.repo.owner,
        repo: context.actionContext.repo.repo,
        'pull_number': number,
    }), () => __awaiter(void 0, void 0, void 0, function* () {
        return (yield octokit.pulls.get({
            owner: context.actionContext.repo.owner,
            repo: context.actionContext.repo.repo,
            'pull_number': number,
        })).data.mergeable;
    }), context);
});
exports.updatePr = (branchName, files, output, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const apiHelper = exports.getApiHelper(new github_1.GitHub(misc_1.getApiToken()), context, logger);
    const pr = yield apiHelper.findPullRequest(branchName);
    if (pr) {
        logger.startProcess('Creating comment to PullRequest...');
        yield apiHelper.createCommentToPr(branchName, yield variables_1.getPrBody(true, files, output, helper, logger, octokit, context));
        return exports.isMergeable(pr.number, octokit, context);
    }
    logger.startProcess('Creating PullRequest...');
    yield apiHelper.pullsCreate(branchName, {
        title: yield variables_1.getPrTitle(helper, logger, octokit, context),
        body: yield variables_1.getPrBody(false, files, output, helper, logger, octokit, context),
    });
    return true;
});
const runCommands = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    const commands = [].concat.apply([], [
        getClearPackageCommands(context),
        getGlobalInstallPackagesCommands(context),
        getDevInstallPackagesCommands(context),
        getInstallPackagesCommands(context),
        getExecuteCommands(context),
    ]);
    logger.startProcess('Running commands...');
    const output = yield helper.runCommand(getWorkspace(), commands);
    return {
        files: yield exports.getDiff(helper, logger),
        output,
    };
});
exports.getChangedFiles = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.clone(helper, logger, octokit, context);
    if (yield exports.checkBranch(helper, logger, octokit, context)) {
        if (!(yield exports.merge(misc_1.getContextBranch(context), helper, logger, context))) {
            yield exports.abortMerge(helper, logger);
        }
    }
    return runCommands(helper, logger, context);
});
exports.getChangedFilesForRebase = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield initDirectory(helper, logger, context);
    yield helper.cloneBranch(getWorkspace(), misc_1.getPrHeadRef(context), context.actionContext);
    yield helper.createBranch(getWorkspace(), yield variables_1.getPrBranchName(helper, logger, octokit, context));
    return runCommands(helper, logger, context);
});
exports.closePR = (branchName, logger, octokit, context, message) => __awaiter(void 0, void 0, void 0, function* () { return exports.getApiHelper(new github_1.GitHub(misc_1.getApiToken()), context, logger).closePR(branchName, (message !== null && message !== void 0 ? message : context.actionDetail.prCloseMessage)); });
exports.resolveConflicts = (branchName, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (yield exports.merge(misc_1.getContextBranch(context), helper, logger, context)) {
        // succeeded to merge
        yield exports.push(branchName, helper, logger, context);
    }
    else {
        // failed to merge
        const { files, output } = yield exports.getChangedFilesForRebase(helper, logger, octokit, context);
        if (!files.length) {
            yield exports.closePR(branchName, logger, octokit, context);
            return;
        }
        yield exports.commit(helper, logger, context);
        yield forcePush(branchName, helper, logger, context);
        yield exports.getApiHelper(new github_1.GitHub(misc_1.getApiToken()), context, logger).pullsCreateOrUpdate(branchName, {
            title: yield variables_1.getPrTitle(helper, logger, octokit, context),
            body: yield variables_1.getPrBody(false, files, output, helper, logger, octokit, context),
        });
    }
});
exports.getDefaultBranch = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    return misc_1.getCache(misc_1.getCacheKey('repos', {
        owner: context.actionContext.repo.owner,
        repo: context.actionContext.repo.repo,
    }), () => __awaiter(void 0, void 0, void 0, function* () {
        return (yield octokit.repos.get({
            owner: context.actionContext.repo.owner,
            repo: context.actionContext.repo.repo,
        })).data.default_branch;
    }), context);
});
exports.getNewPatchVersion = (helper, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('new-patch-version'), () => __awaiter(void 0, void 0, void 0, function* () { return helper.getNewPatchVersion(getWorkspace()); }), context); });
exports.findPR = (branchName, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return misc_1.getCache(misc_1.getCacheKey('pr', { branchName }), () => __awaiter(void 0, void 0, void 0, function* () { return exports.getApiHelper(octokit, context, logger).findPullRequest(branchName); }), context); });
