"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const github_action_helper_1 = require("@technote-space/github-action-helper");
const core_1 = require("@actions/core");
const misc_1 = require("./misc");
const { getWorkspace, useNpm } = github_action_helper_1.Utils;
const { getRepository, isPush } = github_action_helper_1.ContextHelper;
const cache = {};
exports.clearCache = () => Object.getOwnPropertyNames(cache).forEach(prop => delete cache[prop]);
exports.getApiHelper = (logger) => new github_action_helper_1.ApiHelper(logger);
exports.clone = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Cloning [%s] branch from the remote repo...', yield misc_1.getPrBranchName(helper, context));
    yield helper.cloneBranch(getWorkspace(), yield misc_1.getPrBranchName(helper, context), context.actionContext);
});
exports.checkBranch = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    const clonedBranch = yield helper.getCurrentBranchName(getWorkspace());
    if ((yield misc_1.getPrBranchName(helper, context)) === clonedBranch) {
        yield helper.runCommand(getWorkspace(), 'ls -la');
        return !isPush(context.actionContext);
    }
    if (isPush(context.actionContext)) {
        throw new Error(`remote branch [${yield misc_1.getPrBranchName(helper, context)}] not found.`);
    }
    logger.info('remote branch [%s] not found.', yield misc_1.getPrBranchName(helper, context));
    logger.info('now branch: %s', clonedBranch);
    logger.startProcess('Cloning [%s] from the remote repo...', misc_1.getPrHeadRef(context));
    yield helper.cloneBranch(getWorkspace(), misc_1.getPrHeadRef(context), context.actionContext);
    yield helper.createBranch(getWorkspace(), yield misc_1.getPrBranchName(helper, context));
    yield helper.runCommand(getWorkspace(), 'ls -la');
    return false;
});
const getClearPackageCommands = (context) => {
    if (misc_1.isDisabledDeletePackage(context)) {
        return [];
    }
    return [
        'rm -f package.json',
        'rm -f package-lock.json',
        'rm -f yarn.lock',
    ];
};
const getGlobalInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('globalInstallPackages', context, []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'sudo npm install -g ' + packages.join(' '),
            ];
        }
        else {
            return [
                'sudo yarn global add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getDevInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('devInstallPackages', context, []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save-dev ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add --dev ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getInstallPackagesCommands = (context) => {
    const packages = misc_1.getActionDetail('installPackages', context, []);
    if (packages.length) {
        if (useNpm(getWorkspace(), core_1.getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const normalizeCommand = (command) => command.trim().replace(/\s{2,}/g, ' ');
const getExecuteCommands = (context) => misc_1.getActionDetail('executeCommands', context, []).map(normalizeCommand);
exports.getDiff = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Checking diff...');
    yield helper.runCommand(getWorkspace(), 'git add --all');
    return yield helper.getDiff(getWorkspace());
});
exports.getRefDiff = (compare, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Checking references diff...');
    yield helper.fetchBranch(getWorkspace(), compare, context.actionContext);
    return (yield helper.getRefDiff(getWorkspace(), 'HEAD', compare, misc_1.getGitFilterStatus(context), '..')).filter(line => misc_1.filterExtension(line, context));
});
const initDirectory = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Initializing working directory...');
    yield helper.runCommand(getWorkspace(), 'rm -rdf ./* ./.[!.]*');
    fs_1.mkdirSync(getWorkspace(), { recursive: true });
});
exports.config = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    const name = misc_1.getCommitName(context);
    const email = misc_1.getCommitEmail(context);
    logger.startProcess('Configuring git committer to be %s <%s>', name, email);
    yield helper.config(getWorkspace(), name, email);
});
exports.merge = (branch, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.config(helper, logger, context);
    logger.startProcess('Merging [%s] branch...', branch.replace(/^(refs\/)?heads/, ''));
    const results = yield helper.runCommand(getWorkspace(), `git merge --no-edit origin/${branch.replace(/^(refs\/)?heads/, '')} || :`);
    return !results[0].stdout.some(RegExp.prototype.test, /^CONFLICT /);
});
exports.abortMerge = (helper, logger) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Aborting merge...');
    yield helper.runCommand(getWorkspace(), 'git merge --abort');
});
exports.commit = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield exports.config(helper, logger, context);
    logger.startProcess('Committing...');
    yield helper.makeCommit(getWorkspace(), misc_1.getCommitMessage(context));
});
exports.push = (branchName, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    yield helper.push(getWorkspace(), branchName, false, context.actionContext);
});
const forcePush = (branchName, helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    yield helper.forcePush(getWorkspace(), branchName, context.actionContext);
});
const getCacheKey = (method, args) => method + JSON.stringify(args);
exports.isMergeable = (number, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const key = getCacheKey('pulls.get', {
        owner: context.actionContext.repo.owner,
        repo: context.actionContext.repo.repo,
        'pull_number': number,
    });
    if (!(key in cache)) {
        // eslint-disable-next-line require-atomic-updates
        cache[key] = (yield octokit.pulls.get({
            owner: context.actionContext.repo.owner,
            repo: context.actionContext.repo.repo,
            'pull_number': number,
        })).data.mergeable;
    }
    return cache[key];
});
exports.updatePr = (branchName, files, output, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const info = yield exports.getApiHelper(logger).pullsCreateOrComment(branchName, {
        title: yield misc_1.getPrTitle(helper, context),
        body: yield misc_1.getPrBody(files, output, helper, context),
    }, octokit, context.actionContext);
    if (!info.isPrCreated) {
        // updated PR
        return exports.isMergeable(info.number, octokit, context);
    }
    return true;
});
const runCommands = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    const commands = [].concat.apply([], [
        getClearPackageCommands(context),
        getGlobalInstallPackagesCommands(context),
        getDevInstallPackagesCommands(context),
        getInstallPackagesCommands(context),
        getExecuteCommands(context),
    ]);
    logger.startProcess('Running commands...');
    const output = yield helper.runCommand(getWorkspace(), commands);
    return {
        files: yield exports.getDiff(helper, logger),
        output,
    };
});
exports.getChangedFiles = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield initDirectory(helper, logger);
    yield exports.clone(helper, logger, context);
    if (yield exports.checkBranch(helper, logger, context)) {
        if (!(yield exports.merge(misc_1.getPrHeadRef(context), helper, logger, context))) {
            yield exports.abortMerge(helper, logger);
        }
    }
    return runCommands(helper, logger, context);
});
exports.getChangedFilesForRebase = (helper, logger, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield initDirectory(helper, logger);
    yield helper.cloneBranch(getWorkspace(), misc_1.getPrHeadRef(context), context.actionContext);
    yield helper.createBranch(getWorkspace(), yield misc_1.getPrBranchName(helper, context));
    return runCommands(helper, logger, context);
});
exports.closePR = (branchName, logger, octokit, context, message) => __awaiter(void 0, void 0, void 0, function* () { return exports.getApiHelper(logger).closePR(branchName, octokit, context.actionContext, (message !== null && message !== void 0 ? message : context.actionDetail.prCloseMessage)); });
exports.resolveConflicts = (branchName, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (yield exports.merge(misc_1.getPrHeadRef(context), helper, logger, context)) {
        // succeeded to merge
        yield exports.push(branchName, helper, logger, context);
    }
    else {
        // failed to merge
        const { files, output } = yield exports.getChangedFilesForRebase(helper, logger, context);
        if (!files.length) {
            yield exports.closePR(branchName, logger, octokit, context);
            return;
        }
        yield exports.commit(helper, logger, context);
        yield forcePush(branchName, helper, logger, context);
        yield exports.getApiHelper(logger).pullsCreateOrUpdate(branchName, {
            title: yield misc_1.getPrTitle(helper, context),
            body: yield misc_1.getPrBody(files, output, helper, context),
        }, octokit, context.actionContext);
    }
});
exports.getDefaultBranch = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const key = getCacheKey('repos', {
        owner: context.repo.owner,
        repo: context.repo.repo,
    });
    if (!(key in cache)) {
        // eslint-disable-next-line require-atomic-updates
        cache[key] = (yield octokit.repos.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
        })).data.default_branch;
    }
    return cache[key];
});
exports.getNewPatchVersion = (helper) => __awaiter(void 0, void 0, void 0, function* () { return helper.getNewPatchVersion(getWorkspace()); });
//# sourceMappingURL=command.js.map