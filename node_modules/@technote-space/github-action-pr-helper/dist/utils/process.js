"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const github_action_helper_1 = require("@technote-space/github-action-helper");
const command_1 = require("./command");
const misc_1 = require("./misc");
const constant_1 = require("../constant");
const { sleep, getBranch } = github_action_helper_1.Utils;
const { isPr, isCron, isPush } = github_action_helper_1.ContextHelper;
const commonLogger = new github_action_helper_1.Logger(misc_1.replaceDirectory);
const getResult = (result, detail, context) => ({
    result,
    detail,
    branch: misc_1.getPrHeadRef(context),
});
const checkActionPr = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const pr = yield command_1.getApiHelper(logger).findPullRequest(misc_1.getPrHeadRef(context), octokit, context.actionContext);
    if (!pr) {
        return getResult('failed', 'not found', context);
    }
    if (pr.base.ref === context.defaultBranch) {
        return true;
    }
    const basePr = yield command_1.getApiHelper(logger).findPullRequest(pr.base.ref, octokit, context.actionContext);
    if (!basePr) {
        yield command_1.closePR(misc_1.getPrHeadRef(context), logger, octokit, context, '');
        return getResult('succeeded', 'has been closed because base PullRequest does not exist', context);
    }
    if (basePr.state === 'closed') {
        yield command_1.closePR(misc_1.getPrHeadRef(context), logger, octokit, context, '');
        return getResult('succeeded', 'has been closed because base PullRequest has been closed', context);
    }
    return true;
});
const createPr = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (isCron(context.actionContext)) {
        commonLogger.startProcess('Target PullRequest Ref [%s]', misc_1.getPrHeadRef(context));
    }
    if (misc_1.isActionPr(context)) {
        const result = yield checkActionPr(helper, logger, octokit, context);
        if (result !== true) {
            return result;
        }
    }
    if (!misc_1.isTargetBranch(misc_1.getPrHeadRef(context), context)) {
        return getResult('skipped', 'This is not target branch', context);
    }
    let mergeable = false;
    const branchName = misc_1.getPrBranchName(context);
    const { files, output } = yield command_1.getChangedFiles(helper, logger, context);
    let result = 'succeeded';
    let detail = 'updated';
    if (!files.length) {
        logger.info('There is no diff.');
        const pr = yield command_1.getApiHelper(logger).findPullRequest(branchName, octokit, context.actionContext);
        if (!pr) {
            // There is no PR
            return getResult('skipped', 'There is no diff', context);
        }
        if (!(yield command_1.getRefDiff(misc_1.getPrHeadRef(context), helper, logger, context)).length) {
            // Close if there is no diff
            yield command_1.closePR(branchName, logger, octokit, context);
            return getResult('succeeded', 'There is no reference diff', context);
        }
        mergeable = yield command_1.isMergeable(pr.number, octokit, context);
        if (mergeable) {
            result = 'skipped';
            detail = 'There is no diff';
        }
    }
    else {
        // Commit local diffs
        yield command_1.commit(helper, logger, context);
        if (!(yield command_1.getRefDiff(misc_1.getPrHeadRef(context), helper, logger, context)).length) {
            // Close if there is no diff
            yield command_1.closePR(branchName, logger, octokit, context);
            return getResult('succeeded', 'has been closed because there is no reference diff', context);
        }
        yield command_1.push(branchName, helper, logger, context);
        mergeable = yield command_1.updatePr(branchName, files, output, logger, octokit, context);
    }
    if (!mergeable) {
        // Resolve conflicts if PR is not mergeable
        yield command_1.resolveConflicts(branchName, helper, logger, octokit, context);
    }
    return getResult(result, detail, context);
});
const createCommit = (helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const branchName = getBranch(context.actionContext);
    if (!misc_1.isTargetBranch(branchName, context)) {
        return;
    }
    const { files } = yield command_1.getChangedFiles(helper, logger, context);
    if (!files.length) {
        logger.info('There is no diff.');
        return;
    }
    yield command_1.commit(helper, logger, context);
    try {
        yield command_1.push(branchName, helper, logger, context);
    }
    catch (error) {
        if (/protected branch hook declined/.test(error.message)) {
            logger.warn('Branch [%s] is protected.', branchName);
            return;
        }
        throw error;
    }
});
const outputResult = (result, endProcess = false) => {
    const mark = {
        'succeeded': commonLogger.c('✔', 'green'),
        'failed': commonLogger.c('×', 'red'),
        'skipped': commonLogger.c('→', 'yellow'),
    };
    if (endProcess) {
        commonLogger.endProcess();
    }
    commonLogger.info(mark[result.result] + '\t[%s] %s', result.branch, result.detail);
};
const outputResults = (results) => {
    const total = results.length;
    const succeeded = results.filter(item => item.result === 'succeeded').length;
    const failed = results.filter(item => item.result === 'failed').length;
    commonLogger.startProcess('Total:%d  Succeeded:%d  Failed:%d  Skipped:%d', total, succeeded, failed, total - succeeded - failed);
    results.forEach(result => outputResult(result));
};
const getActionContext = (context, pull) => ({
    actionContext: Object.assign({}, context.actionContext, {
        payload: {
            'pull_request': {
                number: pull.number,
                id: pull.id,
                head: pull.head,
                base: pull.base,
                title: pull.title,
                'html_url': pull.html_url,
            },
        },
        repo: {
            owner: pull.base.repo.owner.login,
            repo: pull.base.repo.name,
        },
        ref: pull.head.ref,
    }),
    actionDetail: context.actionDetail,
    defaultBranch: context.defaultBranch,
});
exports.execute = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a;
    if (misc_1.isClosePR(context)) {
        yield command_1.closePR(misc_1.getPrBranchName(context), commonLogger, octokit, context);
        return;
    }
    const helper = misc_1.getHelper(context);
    if (isPush(context.actionContext)) {
        yield createCommit(helper, commonLogger, octokit, context);
    }
    else if (isPr(context.actionContext)) {
        outputResult(yield createPr(helper, commonLogger, octokit, context), true);
    }
    else {
        const logger = new github_action_helper_1.Logger(misc_1.replaceDirectory, true);
        const results = [];
        if (misc_1.checkDefaultBranch(context)) {
            try {
                results.push(yield createPr(helper, logger, octokit, getActionContext(context, misc_1.getPullsArgsForDefaultBranch(context))));
            }
            catch (error) {
                results.push(getResult('failed', error.message, getActionContext(context, misc_1.getPullsArgsForDefaultBranch(context))));
            }
        }
        try {
            for (var _b = __asyncValues(command_1.getApiHelper(logger).pullsList({}, octokit, context.actionContext)), _c; _c = yield _b.next(), !_c.done;) {
                const pull = _c.value;
                yield sleep(constant_1.INTERVAL_MS);
                try {
                    results.push(yield createPr(helper, logger, octokit, getActionContext(context, pull)));
                }
                catch (error) {
                    results.push(getResult('failed', error.message, getActionContext(context, pull)));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        yield outputResults(results);
    }
    commonLogger.endProcess();
});
//# sourceMappingURL=process.js.map